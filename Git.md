# Git reference

Git is a ubiquitous version control system used in nearly every facet of EECS. It's primary function is to allow the user to go back to older working copies of the software. In addition to version control, Git is indispensible as a collaboration tool, allowing two users to make changes to the same copy of some code, then merge the new changed copies together.

## Terms

* `repo`: A folder of files that Git is tracking
* `commit`: A snapshot of your code at some point in time.
* `branch`: A chain of commits leading to a particular state
* `stage`: To mark a file for commiting
* `master`: The main branch of a repository

## Commands

#### `commit`

If you are working alone, 40% of the Git commands that you use will be `git commit -am "XXX"`. By creating a commit, you are telling Git what changes you have made since your last commit. Git's usefullness as a version control program depends heavily on the descriptiveness of your commit messages. See the Additional Reading section for a guide on how to style commit messages.

#### `checkout`

The `git checkout XXX` command changes your files to a particular snapshot. XXX in this case can be the name of a branch or the hash of a commit (a 7 or 40 character hexadecimal value that represents a commit). You can use `git checkout -b XXX` to create a new branch called XXX. In most cases, branches are used to test out changes before releasing them. In the context of personal and class projects, it's technically fine to work exclusively on the master branch, but using branches makes it very easy to go back and forth between commits and compare states.

#### `push`

It is generally a good practice to push after every commit. The following code is a script that can be used to add, commit, and push all of your new changes:
```sh
git status -s -b
CHANGED=$(git status -s)
if [ -n "$CHANGED" ]; then
  read -r -e -p 'Commit message: ' desc  # prompt user for commit message
  git add -A                             # track all files
  git commit -m "$desc"                  # commit with message
fi
git push                                 # push to origin
```

#### `pull`

Note: If you cannot pull because you have uncommitted changes and for some reason don't want to commit (committing is almost always the best option in this case, even if it feels like the wrong thing to do), then use `git stash`, pull, then use `git stash pop` to apply the new changes as if you had been working on the pulled version. Regardless of how you apply your changes, you may need to resolve some merge conflicts.

#### `log`

Use this command to see the last few commits.

#### `branch`

Because `git checkout -b` exists, you'll generally only use branch to list all available branches (`git branch`) or delete a branch that you're done with (`git branch -d XXX`).

## .gitignore

Put names of files and directories that you don't need the history of. Generally, this will be compiled code, automatically generated backups, and other extraneous files that are generated by running commands or programs.

## Additional Reading
[Git commit style](https://chris.beams.io/posts/git-commit/)
[Fixing merge conflicts](https://youtu.be/g8BRcB9NLp4)
[git add * vs git add .](https://stackoverflow.com/questions/26042390/git-add-asterisk-vs-git-add-period#26042555)
[The Git book](https://git-scm.com/book/en/v2)
[git command glossary](https://git-scm.com/docs)
